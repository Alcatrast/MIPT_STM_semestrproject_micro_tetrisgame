/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <string.h>
#include "st7735.h"
#include "fonts.h"
#include <math.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

SPI_HandleTypeDef hspi1;

TIM_HandleTypeDef htim10;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_SPI1_Init(void);
static void MX_ADC1_Init(void);
static void MX_TIM10_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

// ===== Цвета (как в змейке: snake_color, fruit_color и т.д.) =====
#define snake_color 0x4BBF   // Зеленоватый — для тела фигур
#define field_color 0xFFFF   // Белый фон
#define head_color ST7735_BLUE   // Голова → цвет текущей фигуры (динамически)
#define fruit_color ST7735_RED   // Фрукт → красный (не используется, но оставлено)

// ===== Тетрис: параметры поля =====
#define BOARD_WIDTH 10
#define BOARD_HEIGHT 20
#define TOTAL_HEIGHT (BOARD_HEIGHT + 2) // 2 строки сверху для спавна

uint16_t board[TOTAL_HEIGHT][BOARD_WIDTH]; // 1 = занято
uint16_t colorBoard[TOTAL_HEIGHT][BOARD_WIDTH]; // цвет клетки

// Фигуры: 7 типов, 4 поворота, 4x4
const int shapes[7][4][4][4] = {
    // I
    {{{0,0,0,0},{1,1,1,1},{0,0,0,0},{0,0,0,0}}, {{0,0,1,0},{0,0,1,0},{0,0,1,0},{0,0,1,0}}, {{0,0,0,0},{0,0,0,0},{1,1,1,1},{0,0,0,0}}, {{0,1,0,0},{0,1,0,0},{0,1,0,0},{0,1,0,0}}},
    // O
    {{{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}}, {{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}}, {{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}}, {{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}}},
    // T
    {{{0,0,0,0},{0,1,0,0},{1,1,1,0},{0,0,0,0}}, {{0,1,0,0},{0,1,1,0},{0,1,0,0},{0,0,0,0}}, {{0,0,0,0},{1,1,1,0},{0,1,0,0},{0,0,0,0}}, {{0,1,0,0},{1,1,0,0},{0,1,0,0},{0,0,0,0}}},
    // S
    {{{0,0,0,0},{0,1,1,0},{1,1,0,0},{0,0,0,0}}, {{0,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,0,0}}, {{0,0,0,0},{0,1,1,0},{1,1,0,0},{0,0,0,0}}, {{0,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,0,0}}},
    // Z
    {{{0,0,0,0},{1,1,0,0},{0,1,1,0},{0,0,0,0}}, {{0,0,1,0},{0,1,1,0},{0,1,0,0},{0,0,0,0}}, {{0,0,0,0},{1,1,0,0},{0,1,1,0},{0,0,0,0}}, {{0,0,1,0},{0,1,1,0},{0,1,0,0},{0,0,0,0}}},
    // J
    {{{0,0,0,0},{1,0,0,0},{1,1,1,0},{0,0,0,0}}, {{0,1,1,0},{0,1,0,0},{0,1,0,0},{0,0,0,0}}, {{0,0,0,0},{1,1,1,0},{0,0,1,0},{0,0,0,0}}, {{0,1,0,0},{0,1,0,0},{1,1,0,0},{0,0,0,0}}},
    // L
    {{{0,0,0,0},{0,0,1,0},{1,1,1,0},{0,0,0,0}}, {{0,1,0,0},{0,1,0,0},{0,1,1,0},{0,0,0,0}}, {{0,0,0,0},{1,1,1,0},{1,0,0,0},{0,0,0,0}}, {{1,1,0,0},{0,1,0,0},{0,1,0,0},{0,0,0,0}}}
};

const uint16_t shapeColors[7] = {
    ST7735_CYAN,    // I
    ST7735_YELLOW,  // O
    0x781F,         // T (фиолетовый)
    ST7735_GREEN,   // S
    ST7735_RED,     // Z
    ST7735_BLUE,    // J
    0xFEA0          // L (оранжевый)
};

typedef struct {
    int x, y, shape, rotation;
} Tetromino;

Tetromino current, next;
int dropCounter = 0;
int dropInterval = 30; // ~1.5 сек при 20 FPS
int score = 0;
int lines = 0;

// ===== Состояние debounce (как в змейке) =====
int pr1 = 0, pr2 = 0, pr3 = 0, pr4 = 0, pr5 = 0, pr6 = 0, pr7 = 0, pr8 = 0,
    pr9 = 0, pr10 = 0, pr11 = 0, pr12 = 0, pr13 = 0, pr14 = 0, pr15 = 0, pr16 = 0;
int adcData[2];
int flag_k = 1; // 1 — клавиатура, -1 — джойстик
int key = 7;    // как в змейке: 7 = "пауза"/ждать команды

// ===== Функции ввода (100% как в змейке) =====
int klav(){
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, 0);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, 1);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, 1);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, 1);
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_5) != GPIO_PIN_SET) { if(pr1 == 0){ return 1; } pr1 = 1; } else pr1 = 0;
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_4) != GPIO_PIN_SET) { if(pr2 == 0){ return 2; } pr2 = 1; } else pr2 = 0;
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_3) != GPIO_PIN_SET) { if(pr3 == 0){ return 3; } pr3 = 1; } else pr3 = 0;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_15) != GPIO_PIN_SET) { if(pr4 == 0){ return 4; } pr4 = 1; } else pr4 = 0;

    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, 1);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, 0);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, 1);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, 1);
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_5) != GPIO_PIN_SET) { if(pr5 == 0){ return 5; } pr5 = 1; } else pr5 = 0;
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_4) != GPIO_PIN_SET) { if(pr6 == 0){ return 6; } pr6 = 1; } else pr6 = 0;
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_3) != GPIO_PIN_SET) { if(pr7 == 0){ return 7; } pr7 = 1; } else pr7 = 0;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_15) != GPIO_PIN_SET) { if(pr8 == 0){ return 8; } pr8 = 1; } else pr8 = 0;

    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, 1);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, 1);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, 0);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, 1);
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_5) != GPIO_PIN_SET) { if(pr9 == 0){ return 9; } pr9 = 1; } else pr9 = 0;
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_4) != GPIO_PIN_SET) { if(pr10 == 0){ return 10; } pr10 = 1; } else pr10 = 0;
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_3) != GPIO_PIN_SET) { if(pr11 == 0){ return 11; } pr11 = 1; } else pr11 = 0;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_15) != GPIO_PIN_SET) { if(pr12 == 0){ return 12; } pr12 = 1; } else pr12 = 0;

    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, 1);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, 1);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, 1);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, 0);
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_5) != GPIO_PIN_SET) { if(pr13 == 0){ return 13; } pr13 = 1; } else pr13 = 0;
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_4) != GPIO_PIN_SET) { if(pr14 == 0){ return 14; } pr14 = 1; } else pr14 = 0;
    if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_3) != GPIO_PIN_SET) { if(pr15 == 0){ return 15; } pr15 = 1; } else pr15 = 0;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_15) != GPIO_PIN_SET) { if(pr16 == 0){ return 16; } pr16 = 1; } else pr16 = 0;
    return 0;
}

int joystick(int x, int y){
    int d = 0;
    if (x > 2048+600 && 2048 - 600 < y && y < 2048 + 600) d = 8;
    if (x < 2048-600 && 2048 - 600 < y && y < 2048 + 600) d = 6;
    if (2048 - 600 < x && x < 2048 + 600 && y > 2048+600) d = 11;
    if (2048 - 600 < x && x < 2048 + 600 && y < 2048-600) d = 3;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_12) == 0) d = 13;
    return d;
}

void input() {
    int k = 0;
    if (flag_k == 1) {
        k = klav();
    }
    if (flag_k == -1) {
        HAL_ADC_Start_DMA(&hadc1, adcData, 2);
        k = joystick(adcData[0], adcData[1]);
    }
    if (k == 13) {
        flag_k *= -1;
        key = 7; // как в змейке!
    }
    if (k != 0 && k != 13) {
        key = k; // сохраняем команду (6,8,3,11)
    }
}

// ===== Вспомогательные функции Тетриса (внутри main.c) =====
void clearBoard() {
    for (int y = 0; y < TOTAL_HEIGHT; y++)
        for (int x = 0; x < BOARD_WIDTH; x++)
            board[y][x] = 0;
}

int canPlace(Tetromino* p) {
    for (int py = 0; py < 4; py++)
        for (int px = 0; px < 4; px++)
            if (shapes[p->shape][p->rotation][py][px]) {
                int x = p->x + px, y = p->y + py;
                if (x < 0 || x >= BOARD_WIDTH || y >= TOTAL_HEIGHT || (y >= 0 && board[y][x])) return 0;
            }
    return 1;
}

void placePiece(Tetromino* p, uint16_t color) {
    for (int py = 0; py < 4; py++)
        for (int px = 0; px < 4; px++)
            if (shapes[p->shape][p->rotation][py][px]) {
                int x = p->x + px, y = p->y + py;
                if (y >= 0 && y < TOTAL_HEIGHT && x >= 0 && x < BOARD_WIDTH) {
                    board[y][x] = 1;
                    colorBoard[y][x] = color;
                }
            }
}

void removePiece(Tetromino* p) {
    for (int py = 0; py < 4; py++)
        for (int px = 0; px < 4; px++)
            if (shapes[p->shape][p->rotation][py][px]) {
                int x = p->x + px, y = p->y + py;
                if (y >= 0 && y < TOTAL_HEIGHT && x >= 0 && x < BOARD_WIDTH) {
                    board[y][x] = 0;
                    colorBoard[y][x] = field_color;
                }
            }
}

void drawCell(int x, int y, uint16_t color) {
    for (int i = 0; i < 25; i++) {
        ST7735_DrawPixel(x*5+4+i/5, y*5+5+i%5, color);
    }
}

void drawBoard() {
    ST7735_FillScreenFast(field_color);
    // Рамка (как в змейке)
    for(int i = 0; i < 161; i++){
        ST7735_DrawPixel(0, i, ST7735_BLACK); ST7735_DrawPixel(1, i, ST7735_BLACK);
        ST7735_DrawPixel(2, i, ST7735_BLACK); ST7735_DrawPixel(3, i, ST7735_BLACK);
        ST7735_DrawPixel(128-4, i, ST7735_BLACK); ST7735_DrawPixel(128-3, i, ST7735_BLACK);
        ST7735_DrawPixel(128-2, i, ST7735_BLACK); ST7735_DrawPixel(128-1, i, ST7735_BLACK);
    }
    for(int i = 4; i < 124; i++){
        ST7735_DrawPixel(i, 0, ST7735_BLACK); ST7735_DrawPixel(i, 1, ST7735_BLACK);
        ST7735_DrawPixel(i, 2, ST7735_BLACK); ST7735_DrawPixel(i, 3, ST7735_BLACK);
        ST7735_DrawPixel(i, 160-1-16, ST7735_BLACK); ST7735_DrawPixel(i, 160-2-16, ST7735_BLACK);
        ST7735_DrawPixel(i, 160-3-16, ST7735_BLACK); ST7735_DrawPixel(i, 160-4-16, ST7735_BLACK);
    }
    // Поле 24x27 → преобразуем в 10x20: масштабируем
    for (int y = 0; y < BOARD_HEIGHT; y++)
        for (int x = 0; x < BOARD_WIDTH; x++)
            if (board[y+2][x]) // пропускаем 2 верхние строки
                drawCell(x*2, y, colorBoard[y+2][x]); // масштаб: x*2 чтобы влезло в 24
}

void checkLines() {
    int linesCleared = 0;
    for (int y = TOTAL_HEIGHT-1; y >= 2; y--) {
        int full = 1;
        for (int x = 0; x < BOARD_WIDTH; x++) if (!board[y][x]) { full = 0; break; }
        if (full) {
            linesCleared++;
            for (int yy = y; yy > 2; yy--)
                for (int x = 0; x < BOARD_WIDTH; x++) {
                    board[yy][x] = board[yy-1][x];
                    colorBoard[yy][x] = colorBoard[yy-1][x];
                }
            for (int x = 0; x < BOARD_WIDTH; x++) board[2][x] = 0;
            y++;
        }
    }
    if (linesCleared) {
        score += (1 << (linesCleared - 1)) * 10;
        dropInterval = 30 - (score / 50) * 2;
        if (dropInterval < 5) dropInterval = 5;
    }
}

// ===== Основные функции (как в змейке: setup, logic, draw) =====
void setup() {
    clearBoard();
    score = 0;
    dropInterval = 30;
    srand(HAL_GetTick());

    current.shape = rand() % 7;
    current.rotation = 0;
    current.x = 3; current.y = 0;

    next.shape = rand() % 7;

    drawBoard();
    char d[20];
    sprintf(d, "Score: %d           ", score);
    ST7735_WriteString(4, 142, d, Font_11x18, ST7735_WHITE, ST7735_BLACK);
}

void logic() {
    dropCounter++;
    if (dropCounter >= dropInterval) {
        dropCounter = 0;
        removePiece(&current);
        current.y++;
        if (!canPlace(&current)) {
            current.y--;
            placePiece(&current, shapeColors[current.shape]);
            checkLines();
            current = next;
            current.x = 3; current.y = 0; current.rotation = 0;
            next.shape = rand() % 7;
            if (!canPlace(&current)) {
                setup(); // как в змейке!
                return;
            }
        }
        drawBoard();
    }

    // Обработка команд (как в змейке!)
    switch (key) {
    case 6: // ←
        removePiece(&current);
        current.x--;
        if (!canPlace(&current)) current.x++;
        else drawBoard();
        key = 7;
        break;
    case 8: // →
        removePiece(&current);
        current.x++;
        if (!canPlace(&current)) current.x--;
        else drawBoard();
        key = 7;
        break;
    case 3: // ↓
        removePiece(&current);
        current.y++;
        if (!canPlace(&current)) current.y--;
        else drawBoard();
        key = 7;
        break;
    case 11: // ↑ = поворот
        removePiece(&current);
        int oldRot = current.rotation;
        current.rotation = (current.rotation + 1) % 4;
        if (!canPlace(&current)) current.rotation = oldRot;
        else drawBoard();
        key = 7;
        break;
    }
}

void draw() {
    // Обновляем Score (как в змейке!)
    char d[20];
    sprintf(d, "Score: %d           ", score);
    ST7735_WriteString(4, 142, d, Font_11x18, ST7735_WHITE, ST7735_BLACK);
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_SPI1_Init();
  MX_ADC1_Init();
  MX_TIM10_Init();

  /* USER CODE BEGIN 2 */
  ST7735_Init();
  setup();
  HAL_TIM_Base_Start_IT(&htim10);
  /* USER CODE END 2 */

  while (1) { }
}

// ... (всё остальное: SystemClock_Config, MX_GPIO_Init, Error_Handler и т.д. — без изменений)
// Оставляем как в оригинальном файле — они уже есть в вашем проекте.
